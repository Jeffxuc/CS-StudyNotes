
1. C++中什么是段错误
   > 段错误是一个运行时的错误，主要是程序试图访问非法的内存地址或无效的内存地址：
   >   -  访问空指针或者已经释放的指针
   >   -  数组越界访问
   >   -  递归导致的栈溢出
2. C++ 模板相关问题
3. 内存屏障是什么
4. 内存对齐相关的问题 --> 缓存命中
5. C++中的数据结构有哪些：
   > 数组，链表，队列，栈， 树，图，哈希表，集合(set)，映射(map) 等
6. 智能指针有哪些，具体的用法
7. C++11有哪些新特性
8. 网络协议有哪些，七层协议，每一层的组件是什么，每一层有哪些协议
9. Socket编程的基本框架和流程。
10. 常用的排序算法手写整个过程
11. 虚函数的相关知识，实现原理，构造函数可以是虚函数吗，为什么。
12. 网络协议的基础知识，TCP为什么需要三次握手，可以是四次握手吗。
13. 设计模式有哪些，挑一些详细讲解
14. C++的几种类型转换，以及具体的使用场景
15. 通过QT来操作，数据库的读写操作。
16. QT 相关的知识：控件的绘制，信号槽相关的知识。
17. Delegate实现表格数据项的数量刷新
18. Qt视图系统
19. Qgraphic qpainter
20. Qtimer多线程id问题
21. QT中子线程可以直接操作UI线程吗
    > 不可以，UI线程一般为主线程，子线程中是无法来直接操作UI的。一般要通过信号槽或 postEvent 来操作UI。类似于WPF/QT 等GUI程序都是无法直接在子线程中去操作UI的。
22. Linux 开发环境，如何调试问题，用过哪些组件，遇到的问题怎么解决
    > 需要的环境：1）文本编辑器：VSCode。2）编译器。3）构建工具 4）调试工具 5）版本控制工具
    > 软件开发的流程：**1. 需求分析**：分析要实现哪些功能和性能指标。 **2. 设计**：设计软件的架构和接口，确定主要的数据结构和算法。**3. 编码**：按照设计进行编码开发。**4. 测试**：运行程序并进行测试，确保程序的正确性和性能。**5.部署**：将程序安装到最终的生产环境中，供用户使用。**6. 维护**： 根据使用的反馈和监控数据，对程序进行优化，更新和维护。

23. Linux 上多线程开发相关操作，需要实例训练
24. C++ 多线程的实例训练
25. 左值跟右值具体指的什么意思，有什么作用
26. std::move如何使用，C++为何需要std::move() :star::star:
27. 程序的编译过程是什么：
    1.  预处理阶段会做哪些什么操作
28. 程序如何运行的，如何从二进制文件开始运行，运行的过程是什么
29. 程序的内存分布是如何的，const常量的代码会在哪里，函数成员的代码在哪里
    > 1）代码段。2）初始化的数据段，如已经初始化的全局变量和静态变量。3）未初始化数据段，如未初始化的全局变量和静态变量。4）堆区。 5）栈区  
    > const修饰的全局变量被放在.data(初始化数据区)
30. 模板函数是在什么时候确定具体的类型的，模板的实现原理是什么
    > - 函数模板是在编译期间确定的，而不是运行期间。在编译期间，根据调用模板函数时传入参数的类型，来生成对应的函数代码，这被称作模板的实例化。
31. C++11/14/17的新特性，以及lambda表达式的作用，它有哪些作用
    > 1. 是一个匿名函数 ，可以在代码中定义一个匿名函数，避免声明和定义一个有名函数的，简化函数的写法。2. 可以作为函数的参数来进行传递，如STL中排序方式等，可以直接传入Lambda表达式。3. 闭包的作用，可以捕获作用域中的变量，形成闭包，直接在Lambda表达式中访问和使用捕获的变量。
32. 静态库和共享库的作用及优势
33. 一个空类的对象会占用内存吗。
    > 一个空类对象至少占用一个字节的大小，具体取决于不同的编译器和平台。<br> 即使一个类没有任何成员，它也要占用一定的内存来确保每个对象都有唯一的地址。因为C++要求每个对象在内存中都要有独立的地址，以便于能够进区分和操作。
34. 程序在运行时，如何确定链接的库的地址是多少
35. 一个程序同时加载共享库`a1.so`, `a2.so`，这两个共享库，又各自使用静态库`m.a`，如果静态库 m.a 中有一个全局变量，则这个静态库被两个动态库加载后，其中的全局变量会出现问题吗
36. 拷贝构造函数是什么，如何使用拷贝构造函数，
37. vector容器的范围for，如果可以删除其中的元素吗。
    > 1. 不可以，因为删除vector容器中的元素是需要erase函数，而该函数的参数只能是迭代器类型的，而不能是容器的元素值。2. 范围for会预存end()的值，如果在序列中增删元素的个数，则会导致end()失效。
38. 虚函数的虚表指针大小，以及同一个类的所有对象，它的虚表是一样的吗？
    > - 虚表指针是一个指针的大小，一般是4字节(64位系统是8字节，指针的大小与具体的所指对象的类型没有关系)。
    > - 虚表是对于类而言的，是类级别的，而不是对象级别的。同一个类的所有对象共享同一个虚表，类的每个对象都会有一个指向这个虚表的指针，称为虚表指针。这样可以节省内存空间，同时在运行时通过虚表指针来动态调用正确的虚函数，实现动态多态。
39. 类对象的this指针，该指针何时需要显式的调用。
    > this 指针是一个隐式的指针，它指向当前的对象。一般调用的时候都是隐式调用。  显示调用的情况如：1）当类的成员变量与成员函数的形参同名时，如果要在成员函数中调用类的成员变量，而不是同名的形参，此时需要显示的用this指针来调用成员变量。2）当成员函数需要返回当前的对象的时候，可以直接返回 *this。
40. Linux系统中锁的描述，下面哪些是错误的：
    1.  spinlock 用于保护临界区代码，不能被中断打断。
    2.  被mutex锁阻止的进程不能休眠
    3.  被rw_lock保护的区域，能够同时有多个读者，但只有一个写者
    4.  原子操作是多核同步的有效手段
    > 分析：1.正确： 自旋锁在获取锁时会一直自旋等待，直到成功获取锁为止。在获取锁期间，如果有其他进程试图获取该锁，它们会一直自旋等待，而不是被中断打断。2. 错误：mutex锁可以用于保护临界区代码，当一个进程获取了mutex锁时，其他试图获取该锁的进程会被阻塞，并且可能进入休眠状态等待锁的释放。3. 正确： rw_lock是一种读写锁，它允许多个线程同时以读模式访问被保护的区域，但只允许一个线程以写模式访问该区域。这样可以提高并发性能，因为多个读操作不会相互干扰，但写操作需要独占访问以确保数据一致性。4. 正确： 原子操作保证了在任何给定时间点上只有一个线程可以执行该操作，因此可以有效地实现多核系统中的同步。当一个线程在执行原子操作时，其他线程必须等待该操作完成才能继续执行。
41. 可重入函数
    > 指能够被多个任务或线程同时调用而不会产生冲突或竞争条件的函数。它需要满足如下几点：1）不使用全局变量或静态变量。2）不使用不可重入函数。3）不使用动态分配的内存，函数内部使用局部变量进行计算。
42. 如果燃烧一根不均匀的绳子，烧完需要1个小时，那么给若干条同样的绳子，如何计时45分钟。
    > 将一根绳子的两端同时点燃，同时将另一根绳子的一端点燃。那么同时点燃两端的这根绳子燃烧完刚好需要30min，而只点燃一端的这根绳子要燃烧完剩下的部分还需要30min。此时将这根绳子剩下部分的另一端也点燃，那么剩下这部分全部燃烧完就只需要15min。此时刚好是45min(30min+15min)







